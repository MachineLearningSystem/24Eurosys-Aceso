# Simulator Design Document

## Simulator Classes Document

### [simulator.Simulator](../simulator/simulator.py)

Provide an instance to simulate the computation graph.

```python
class Simulator()
```

#### Remarks

This class provides methods to simulate the computational time cost as well as the communication time cost of a given computation graph (DAG). The inputs of this class are typically generated by the `PlanAdapter`.

#### Constructor

```python
def __init__(self, nodemetadata_list, device_info)
```

> **Parameters**
>
> 1. nodemetadata_list: a list of namedtuple, storing nodemetadata
> 2. device_info: a list of tuple (device_type, spec_list) containing device info, or a list of class Device, storing all Device objects

#### Private Properties

1. `self.__nodes_metadata`: list of NodeMetadata. All nodes in the graph.
2. `self.__nodes`: list. All nodes that are initialized from nodemetadata.
3. `self.__devices`: dict. {device_name: device_obj}
4. `self.__execution_enqueue_time`: list of tuple (node_index, node enqueue time). Store the enqueue time of each node.
5. `self.__execution_dequeue_time`: list of tuple (node_index, node dequeue time). Store the dequeue time of each node.

#### Public Methods

1. `def reset(self)`: Reset the Simulator, reset simulation time to 0, reset all nodes in DAG
2. `def run(self)`: Run simulation, return total_execution_time: float, node_enqueue_time: list of (node_index, node enqueue time), node_dequeue_time: list of (node_index, node dequeue time)

   > **Returns**
   >
   > 1. float, the total execution time
   > 2. list of (node_index, node enqueue time), the node enqueue time
   > 3. list of (node_index, node dequeue time), the node dequeue time

3) `get_nodes(self)`: Return all nodes in the `Simulator`

#### Private Methods

1. `def __start_all_ready_nodes(self)`: Start all nodes that are in ready status, this function will be called only once at the beginning of a simulation

   > **Returns**
   >
   > 1. float, the earliest complete time
   > 2. Device, the earliest device

2. `def __start_node(self, exec_node)`: Start to execute a node. Enqueue the node into device. The node will be marked as 'executing'.

   > **Parameters**
   >
   > 1. exec_node: The Node obj to be executed

3. `def __find_earliest_complete_device(self)`: Find the device who has a node with the earliest complete time. Return (earliest_complete_time, earliest_device)

4. `def __next_step(self)`: Wait until any executing node is done. Get the timestamp. Mark the node as 'done'. Then dequeue it from device. Update all successor nodes' dependency counter. If a successor node is ready, start it. Return current timestamp.

   > **Returns**
   >
   > float, the earliest complete time

5. `def __init_device(self, device_info)`: Init `self.__devices` via device_info. Raise ValueError if the `device_info` is invalid.
   > **Parameters**
   >
   > 1. device_info: a list of tuple (device_type, spec_list) containing device info, or a list of class Device, storing all Device objects

### [simulator.NodeMetadata](../simulator/node.py)

Provide an instance to store essential data of a node

```python
class NodeMetadata()
```

#### Remarks

This class contains all static essential data to initialize a class `Node`.

#### Constructor

```python
def __init__(self, index=0,
                op='',
                name='',
                device_name='',
                execution_time=0.0,
                output_tensors=[],
                input_ids=[],
                dependency_ids=[],
                successor_ids=[]
                )
```

> **Parameters**
>
> | Name           | DataType     | Description                                       |
> | :------------- | :----------- | :------------------------------------------------ |
> | index          | int          | ID of node                                        |
> | op             | string       | Operation                                         |
> | name           | string       | node name                                         |
> | device_name    | string       | Name of device to run this node                   |
> | execution_time | float        | Estimated execution time, in microsecond          |
> | output_tensors | List(Tensor) | Store the output Tensorsâ€™ information             |
> | input_ids      | List(int)    | ID of all input data nodes                        |
> | dependency_ids | List(int)    | ID of all nodes that only have control dependency |
> | successor_ids  | List(int)    | ID of all nodes depends on this node              |

#### Public Properties

1. `self.index`
2. `self.op`
3. `self.name`
4. `self.device_name`
5. `self.execution_time`
6. `self.output_tensors`
7. `self.input_ids`
8. `self.dependency_ids`
9. `self.successor_ids`

#### Public Methods

1. `def to_dict(self)`: return the dict representation of obj self.

   > **Returns**
   >
   > a dict, representing self obj

2. `def assign_from_dict(self, input_dict)`: assign self.key to input_dict[key]

### [simulator.NodeStatus](../simulator/node.py)

An `Enum` class, providing the status of node. Inherit from `Enum`

1. waiting = 0. Not started.
2. executing = 1. Started, not finished. Only for asynchronized node.
3. done = 2. Finished.

### [simulator.NodeException](../simulator/node.py)

An `Exception` exclusive for class `Node`. Inherit from `Exception`.

#### Constructor

```python
def __init__(self, error_info)
```

> **Parameters**
>
> 1. error_info: string, the description string of this exception

#### Public Properties

1. `self.error_info`: string, the description string of this exception

#### Public Methods

1. `def print_error_info(self)`: print `self.error_info`

### [simulator.Node](../simulator/node.py)

Provide the run-time Node in simulator.

```python
class Node()
```

#### Remarks

This class contains all static and dynamic information of a Node. It will store the node's execution status, the remain_dependency_cnt and etc.

#### Constructor

```python
def __init__(self, metadata, device)
```

> **Parameters**
>
> 1. metadata: class `Nodemetadata`.
> 2. device: class `Device`, the device obj on which this node will be executed.

#### Private Properties

1. `self.__metadata`: class `Nodemetadata`, the metadata of the node.
2. `self.__status`: the Enum of NodeStatus, The status of a node.
3. `self.__remain_dependency_cnt`: int, the number of remaining dependencies
4. `self.__device`, class `Device`, the device runtime object that this node is running on
5. `self.__successor_nodes`, list of Node, Node of successor nodes depends on this node

#### Public Methods

1. `def reset(self)`: reset `self.__remain_dependency_cnt` and `self.__status` based on `self.__metadata`
2. `def is_ready(self)`: return whether this Node is ready to be executed

   > **Returns**
   >
   > bool, whether this Node is ready to be executed

3. `def get_index(self)`: return node index

   > **Returns**
   >
   > int, the index number

4. `def get_op(self)`: return op string

   > **Returns**
   >
   > string, name of 'op'

5. `def get_name(self)`: return node's name

   > **Returns**
   >
   > string, node's name

6. `def get_device_name(self)`: return the device name of this node

   > **Returns**
   >
   > string, the device name

7. `def get_execution_time(self)`: return node's execution time

   > **Returns**
   >
   > float, execution time

8. `def set_execution_time(self, execution_time)`: set the `self.__metadata.execution_time` of current node.

   > **Parameters**
   >
   > 1. execution_time: float, the execution time of the Node

9. `def get_tensors(self)`: return node's tensor list

   > **Returns**
   >
   > list of Tensor, the node's tensor list

10. `def get_status(self)`: return Node status

    > **Returns**
    >
    > NodeStatus, the node's current status

11. `def get_remain_dependency_cnt(self)`: return the number of remaining dependency Nodes

    > **Returns**
    >
    > int, the number of remaining dependency

12. `def decrease_remain_dependency_cnt(self, cnt)`: decrease the number of remaining dependency Nodes by cnt.

    > **Parameters**
    >
    > 1. cnt: int

13. `def renew_successor_nodes(self, node_list)`: use successor index, find and add successor Nodes from node_list to current Node's `self.__successor_nodes`

    > **Parameters**
    >
    > 1. node_list: dict. {index: Node_obj}

14. `def get_successor_nodes(self)`: return the successor nodes list

    > **Returns**
    >
    > list of Node, the successor nodes list

15. `def execute(self, time_now)`: execute the Node if ready. Enqueue this Node to the device with `time_now`. Change the NodeStatus to executing.

    > **Parameters**
    >
    > 1. time_now: float. timestamp of simulation

16. `def finish(self)`: dequeue this Node from device, set status to done

### [simulator.TensorException](../simulator/tensor.py)

An `Exception` exclusive for class `Tensor`. Inherit from `Exception`.

#### Constructor

```python
def __init__(self, error_info)
```

> **Parameters**
>
> 1. error_info: string, the description string of this exception

#### Public Properties

1. `self.error_info`: string, the description string of this exception

#### Public Methods

1. `def print_error_info(self)`: print `self.error_info`

### [simulator.Tensor](../simulator/tensor.py)

Provide the essential data for Node

```python
class Tensor()
```

#### Remarks

This class will be used to initialize `NodeMetadata`.

#### Constructor

```python
def __init__(self,
             tensor_type='int8',
             tensor_size=0):
```

> **Parameters**
>
> 1. tensor_type: string, the type of current tensor.
> 2. tensor_size: int, element number.

#### Public Properties

1. `Tensor.valid_type`: dict, supported tensor typeAIA
2. `self.type`: string, must be a valid type in `Tensor.valid_type`
3. `self.size`: int, total number of elements. The total_bytes = size \* sizeof(type)

#### Public Methods

1. `def get_bytes_size(self)`: get total bytes of current Tensor

   > **Returns**
   >
   > int, tensor size in byte

### [simulator.Device](../simulator/device.py)

Provide the interface for all devices that will be used in Simulator.

```python
class Device()
```

#### Remarks

This class acts as an interface. All devices that are used in Simulator should be inherited from this class, add they should implement `is_idle(self)`, `get_next_node(self)`, `enqueue_node(self, node, time_now)` and `dequeue_node(self)` methods

#### Constructor

```python
def __init__(self, name)
```

> **Parameters**
>
> 1. name: string, the name of current Device

#### Private Properties

1. `self.__name`: string, name of device, every child class should have a name.
2. `self.__next_finish_time`: float, the finish time of current node. The child classes could ignore this property.

#### Public Methods

1. `def name(self)`: get the device name

   > **Returns**
   >
   > string, device' name

2. `def is_idle(self)`: check whether the device is idle, every child class should override this method.

   > **Returns**
   >
   > bool, whether or not the device is idle

3. `def get_next_node(self)`: get the first completed node and its complete time, every child class should override this method.

   > **Returns**
   >
   > 1. Node, the first completed Node
   > 2. float, the complete time of node

4. `def enqueue_node(self, node, time_now)`: enqueue a new node into this device on time_now, every child class should override this method.

   > **Parameters**
   >
   > 1. time_now: float, the enqueue simulation time

5. `def dequeue_node(self)`: dequeue the first completed node from the device, every child class should override this method. Note that **DO NOT** modify the attribute of the node, just modify info of device.

### [simulator.FIFODevice](../simulator/fifo_device.py)

Provide a device in which nodes are scheduled using FIFO. Inherited from Device

```python
class FIFODevice(Device)
```

#### Remarks

This FIFO device will execute the first enqueued node.

#### Constructor

```python
def __init__(self, name)
```

> **Parameters**
>
> 1. name: string, the name of current Device

#### Private Properties

1. `self.__node_queue`: list, the reference of enqueued nodes.
2. `self.__queue_head`: int, the head pointer of node queue

#### Public Methods

1. `def is_idle(self)`: check whether there is node being executed in the device

   > **Returns**
   >
   > bool, whether or not the device is idle

2. `def get_next_node(self)`: get the first completed node and its finish time

   > **Returns**
   >
   > 1. Node, the first completed Node
   > 2. float, the complete time of node

3. `def enqueue_node(self, node, time_now)`: enqueue a new node into this device on time_now.

   > **Parameters**
   >
   > 1. time_now: float, the enqueue simulation time

4. `def dequeue_node(self)`: dequeue the first completed node from the device. If still has node in queue, reset head end time

### [simulator.ComputationDevice](../simulator/computation_device.py)

Provide the base class for all computational devices. Inherited from FIFODevice.

```python
class ComputationDevice(FIFODevice)
```

#### Remarks

This class is the base class of CPU, GPU and other computational devices. This class will have a performance property to measure its ability of computation.

#### Constructor

```python
def __init__(self, name, performance='0bps')
```

> **Parameters**
>
> 1. name: string, the name of current Device
> 2. performance: string, computational performance. e.g. '16Gibps'

#### Private Properties

1. `self.__performance`: float, the performance in bps

#### Public Methods

1. `def get_performance(self)`: Return the performance in bps

   > **Returns**
   >
   > 1. float, the performance in bps

### [simulator.CPU](../simulator/computation_device.py)

Provide a class representing a CPU device. Inherited from ComputationDevice.

```python
class CPU(ComputationDevice)
```

#### Constructor

```python
def __init__(self, name, performance='0bps')
```

> **Parameters**
>
> 1. name: string, the name of current CPU
> 2. performance: string, CPU's computational performance. e.g. '16Gibps'

### [simulator.GPU](../simulator/computation_device.py)

Provide a class representing a GPU device. Inherited from ComputationDevice.

```python
class GPU(ComputationDevice)
```

#### Constructor

```python
def __init__(self, name, performance='0bps')
```

> **Parameters**
>
> 1. name: string, the name of current GPU
> 2. performance: string, GPU's computational performance. e.g. '16Gibps'

### [simulator.DeviceFactory](../simulator/device_factory.py)

Provide a class that can generate Device objects.

```python
class DeviceFactory()
```

#### Remarks

This class is used as a object factory to generate other Device objects

#### Constructor

```python
def __init__(self)
```

#### Public Property

1. `DeviceFactory.valid_device_type`: dict, static variable, storing valid device_type string

#### Public Methods

1. `def generate_device(self, device_type, *spec_list)`: Return a (device_type) class obj based on spec_list

   > **Parameters**
   >
   > 1. `device_type`: string, denoting the type of this device.
   > 2. `spec_list`: list, the parameters to initialize the class.
   >
   > **Returns**
   >
   > Device, the device object generated

### [simulator.network_simulator.Flow](../simulator/network_simulator/flow.py)

Provide the Flow representation of nodes.

```python
class Flow()
```

#### Remarks

Communication Nodes (Send/Recv) will be converted to a Flow in this flow based NetworkSimulator. Each Flow maintain its capacity (aka. bandwidth), and their transfer status, and it may occupy several Links.

#### Constructor

```python
def __init__(self, node, time_now)
```

> **Parameters**
>
> 1. node: class Node, a communication node
> 2. time_now: float, current simulation time

#### Public Properties

1. `self.node`: class Node, the Node that this Flow represents

#### Private Properties

1. `self.__total_data_len`: int, the total total bytes of output tensors
2. `self.__remain_len`: float, the remain length of data in bits
3. `self.__estimated_finish_time`: float, the estimated flow's finish time
4. `self.__available_bandwidth`: float, the current bandwidth of this Flow
5. `self.__last_start_time`: float, the time of latest status change

#### Public Methods

1. `def get_estimated_finish_time(self)`: Return the estimated finish time of current flow
2. `def get_available_bandwidth(self)`: Return the current available bandwidth
3. `def set_available_bandwidth(self, available_bandwidth, time_now)`:Set self.\_\_current_available_bandwidth, then change estimated_finish_time and other flow status. Calculate total executed bytes during [last_start_time, time_now], then update \_\_remain_len and calculate new \_\_estimated_finish_time

   > **Parameters**
   >
   > 1. current_available_bandwidth: float, representing tansfer rate(bps)
   > 2. time_now: float, current time of simulation

#### Private Methods

1. `def __lt__(self, other)`: override '<' operator, Flow is ordered by estimated_finish_time
   > **Parameters**
   >
   > 1. other: Flow

### [simulator.network_simulator.Link](../simulator/network_simulator/link.py)

Provide the unidirectional links connecting every devices.

```python
class Link()
```

#### Remarks

This class is a unidirectional Link from src_name to dst_name with specific link properties. Each link can hold several flows.

#### Constructor

```python
def __init__(self, link_id, source_name,
             dest_name, capacity='0bps', latency='0s')
```

> **Parameters**
>
> 1. link_id: int, the identity of current Link
> 2. source_name: string, name of source device
> 3. dest_name: string, name of destation device
> 4. capacity: string, the capacity of this link
> 5. latency: string, the propagation_latency of the link, reserved for future usage

#### Public Properties

1. `link_id`: int, the unique link identity
2. `source_name`: string, the source device name
3. `dest_name`: string, the destination device name
4. `capacity`: float, the capacity stored in bps
5. `latency`: string, the propagation_latency of the link, reserved for future usage
6. `flows`: list of Flow, the flows that are occupying current Link

#### Private Properties

1. `self.__link_id`: int, in one `NetworkSimulator`, every Link should have a unique link_id
2. `self.__source_name`: string, the source device name
3. `self.__dest_name`: string, the destination device name
4. `self.__capacity`: float, the capacity stored in bps
5. `self.__latency`: string, reserved for future usage
6. `self.__flows`: list of Flow, the flows that are occupying this Link

#### Public Methods

1. `def add_flow(self, flow)`: Add a new flow to this link
2. `def delete_flow(self, flow: Flow)`: Delete specific flow from this link

### [simulator.network_simulator.LinkManager](../simulator/network_simulator/link_manager.py)

LinkManager is mainly used by NetworkSimulator to maintain the Links.

```python
class LinkManager()
```

#### Remarks

This class provides methods to maintain the Link objects and the routing information. NetworkSimulator will initialize this class and use it to get Links' information.

#### Constructor

```python
def __init__(self, links_spec, routing_info_dict)
```

> **Parameters**
>
> 1. links_spec: list of dict, [{'link_id': int, 'source_name': str, 'dest_name': str, 'capacity': str, 'latency': str}]
>
>    src/dest_name format:
>    /server/hostname/DeviceType/DeviceIndex/
>    /switch/switch_name/
>
> 2. routing_info_dict: dict, {(src_name, dst_name, route_index):[id0, id1..]}

#### Public Properties

1. `LinkManager.link_essential_data`: dict, contains all essential attributes that a link_spec should have.
2. `LinkManager.link_extra_data`: dict, contains optional attributes that a link_spec may have.

#### Private Properties

1. `self.__links_dict`: dict, {link_id: Link obj} containing all links
2. `self.__routing_path`: dict, storing routing path: {(src_name, dst_name, route_index):[Link0, Link1..]}

#### Public Methods

1. `def get_routing_path(self, src_name, dst_name, route_index)`: Return a list containing the sequence of Link in this path, return None if not found.

   > **Parameters**
   >
   > 1. src_name: string, the source name of the device
   > 2. dst_name: string, the destination name of the device
   > 3. route_index: int, the routing index

2. `def get_routing(self, node_name)`: Parse the node_name string and return routing path.

   > **Parameters**
   >
   > 1. node_name: string, format: ":send:src_name:dst_name:route_index:"
   >    **Returns**
   >    list of Link, [Link0, Link1..]

3. `def get_link(self, link_id)`: Return a Link with specific link_id
4. `def get_links_dict(self)`: Return a dict {link_id: Link obj} containing all links

#### Private Methods

1. `def __init_links(self, links_spec)`: Check validity of links_spec, and init self.\_\_links using links_spec. This method will only be called during initialization.
2. `def __init_routing_path(self, routing_info_dict)`: Init self.\_\_routing_path via routing_info_dict. This method will only be called during initialization.

### [simulator.network_simulator.NetworkSimulator](../simulator/network_simulator/network_simulator.py)

NetworkSimulator is a Device that will calculate communication Nodes' time cost.

```python
class NetworkSimulator(Device)
```

#### Remarks

This class is the main module to calculate the time cost of communication Nodes. It is inherited from class Device.

#### Constructor

```python
def __init__(self, name, links_spec, routing_info)
```

> **Parameters**
>
> 1. links_spec: list of dict, [{'link_id': int, 'source_name': str, 'dest_name': str, 'capacity': str, 'latency': str}]
>
>    src/dest_name format:
>    /server/hostname/DeviceType/DeviceIndex/
>    /switch/switch_name/
>
> 2. routing_info_dict: dict, {(src_name, dst_name, route_index):[id0, id1..]}

#### Private Properties

1. `self.__flows`: list of Flow, containing all Flows that being executed.
2. `self.__link_manager`: class LinkManager, controlling all Links in the NetworkSimulator

#### Public Methods

1. `def is_idle(self)`: Check whether the network simulator is idle
2. `def get_next_node(self)`: Return (next finish node, estimated finish time)
3. `def enqueue_node(self, node, time_now)`: Enqueue a node and update all the flows. The node will first be turned into a Flow, then add to the list, and update all Flow's capacities
4. `def dequeue_node(self)`: Dequeue the flow with the smallest estimated_finish_time

#### Private Methods

1. `def __update_all_flows_capacities(self, time_now)`: Calculate all flow's capacities, and update flows' status during [last_start_time, time_now). There are two events that will change the flows' capacities: enqueue and dequeue.

   > **Parameters**
   >
   > 1. time_now: float, the current simulation time

2. `def __schedule_link(self, link, flow_current_capacity, unfinished_schedule_flow)`: Schedule flows that in link.flows and in unfinished_schedule_flow, allocate remain capacities equally to these flows. return a dict {flow_obj: flow_schedule_capacity}, which contains all flow in link.flows, denoting capacities.

   > **Parameters**
   >
   > 1. link: class Link
   > 2. flow_current_capacity: dict, {flow_obj: capacity}, denoting the current capacity for each flow
   > 3. unfinished_schedule_flow: a set containing all flows who require more capacity

## Adapters Document

### [adapter.GraphAdapter](../adapter/adapter.py)

The base class for framework adapters. A virtual class.

```python
class GraphAdapter(object)
```

### [adapter.PlanAdapter](../adapter/plan_adapter.py)

Provide an interface for converting plans generated by PlanGen to nodes in the AISimulator.

```python
class PlanAdapter()
```

#### Constructor

```python
def __init__(self)
```

#### Public Methods

1. `def set_plan(self, plan)`: Set self.\_\_plan from a node_list, return False if input is invalid

   > **Parameters**
   >
   > 1. plan: list

2. `def get_plan(self)`: Return the adapted plan

## Utility Functions Document

### [simulator.utility.transfer_rate_to_bps(rate_str)](../simulator/utility.py)

Get transfer rate based on the rate_str

```python
def transfer_rate_to_bps(rate_str)
```

> **Parameters**
>
> 1. `rate_str`: string, representing transfer rate, e.g. '1Kibps' == '1024bps', '1Kbps' == '1000bps'
>
> **Returns**
>
> float, transfer rate in bps
>
> **Support suffix**:
>
> "bps", "bit/s", "[kK]bps", "[kK]bit/s", "[kK]ibps", "[kK]ibit/s",
>
> "[mM]bps", "[mM]bit/s", "[mM]ibps", "[mM]ibit/s",
>
> "[gG]bps", "[gG]bit/s", "[gG]ibps", "[gG]ibit/s",
>
> "[tT]bps", "[tT]bit/s", "[tT]ibps", "[tT]ibit/s"

### [simulator.utility.data_size_to_bit(size_str)](../simulator/utility.py)

Get datasize based on the size_str

```python
def data_size_to_bit(size_str)
```

> **Parameters**
>
> 1. `size_str`: string, representing data size suffix, e.g. '1Kib' == '1024b'
>
> **Returns**
>
> float, data size in bps
>
> **Support suffix**:
>
> 'Bit', 'Byte', 'KiB', 'MiB', 'GiB',
>
> 'TiB', 'PiB', 'EiB',
>
> 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB', 'Kib',
>
> 'Mib', 'Gib', 'Tib', 'Pib', 'Eib', 'kb', 'Mb', 'Gb', 'Tb',
>
> 'Pb', 'Eb', 'Zb', 'Yb'
